"""
DO NOT MODIFY THIS FILE. {# Unless you see this comment, in which case you are modifying the template. #} It is automatically generated and changes will be over-written
on the next generation.

This is the Server for the {{stinger.name}} interface.
"""

import json
from typing import Callable
from connection import BrokerConnection
import {{stinger.get_enum_module_name()}} as {{stinger.get_enum_module_alias()}}

class {{stinger.name}}Server(object):

    def __init__(self, connection: BrokerConnection):
        self._conn = connection
        self._conn.set_last_will(topic="{{stinger.interface_info.0}}", payload=None, qos=1, retain=True)
        {%for p,v in stinger.params.items()-%}
        self._{{p}} = {{v.payload.initialValue}}
        self._conn.subscribe("{{topics.get_param_value(stinger.name, false, p)}}", self.set_{{p}})
        self.changed_value_callback_for_{{p}} = None
        self._publish_interface_info()
        {%endfor-%}
        {%for method_name, method in stinger.methods.items()-%}
        self._{{method_name|snake_case}}_method_handler = None
        {%endfor%}
    
    def _publish_interface_info(self):
        self._conn.publish("{{stinger.interface_info.0}}", '''{{stinger.interface_info.1 | tojson}}''', qos=1, retain=True)

    {%for sig_name, sig in stinger.signals.items()-%}
    def emit_{{sig_name}}(self, {%for arg in sig.arg_list%}{{arg.name}}: {{arg.python_type}}{%if not loop.last%}, {%endif%}{%endfor%}):
        {%for arg in sig.arg_list%}
        if not isinstance({{arg.name}}, {{arg.python_type}}):
            raise ValueError(f"The '{{arg.name}}' value must be {{arg.python_type}}.")
        {%-endfor%}
        
        payload = { {%-for arg in sig.arg_list%}
            {%if arg.arg_type.name.lower() == 'value'%}"{{arg.name}}": {{arg.python_type}}({{arg.name}}),{%endif-%}
            {%if arg.arg_type.name.lower() == 'enum'%}"{{arg.name}}": {{arg.python_type}}({{arg.name}}).value,{%endif%}{%endfor%}
        }
        self._conn.publish("{{sig.topic}}", json.dumps(payload), qos=1, retain=False)

    {%endfor%}

    {%for method_name, method in stinger.methods.items()%}
    def handle_{{method_name | snake_case}}(self, handler: Callable[[{%for arg in method.arg_list%}{{arg.python_type}}{%if not loop.last%}, {%endif%}{%endfor%}], {%if method.has_no_return_value%}None{%elif method.has_simple_return_value%}{{method.return_value.python_type}}{%else%}FIXME{%endif%}]):
        do_subscribe = False
        if self._{{method_name|snake_case}}_method_handler is None and handler is not None:
            do_subscribe = True
        self._{{method_name|snake_case}}_method_handler = handler
        if do_subscribe:
            self._conn.subscribe("{{method.topic}}")

    def _process_{{method_name | snake_case}}_call(self, topic, payload):
        if self._{{method_name|snake_case}}_method_handler is not None:
            method_args = []
            for required_arg in [{%for arg in method.method_args%}"{{arg.name}}", {%endfor%}]:
                if required_arg in payload:
                    method_args.append(payload[required_arg])
                else:
                    raise ValueError("Missing argument")
            return_value = self._{{method_name|snake_case}}_method_handler(*method_args)
            if len(return_value) != {{method.return_value_list|length}}:
                raise ValueError("Incorrect number of return arguments")
            
    {%endfor%}

    {%for p,v in stinger.params.items()-%}
    {%-set args = payload(v['payload']) %}
    def set_{{p}}(self, {%for arg in args%}{{arg.name}}{%if not loop.last%}, {%endif%}{%endfor%}):
        changed = False
        {%for arg in payload(v['payload'])-%}
        if {{arg.name}} != self._{{p}}['{{arg.name}}']:
            changed = True
            self._{{p}}['{{arg.name}}'] = {{arg.name}}
        {%endfor-%}
        if changed:
            topic = "{{topics.get_param_value(stinger.name, false, p)}}"
            self._conn.publish(topic, self._{{p}}, 1, True)
            if self.changed_value_callback_for_{{p}} is not None:
                self.changed_value_callback_for_{{p}}({%for arg in args%}{{arg.name}}{%if not loop.last%}, {%endif%}{%endfor%})

    def get_{{p}}(self):
        {%if args | length > 1 -%}
        return self._{{p}}
        {%-else-%}
        return self._{{p}}[args[0].name]
        {%-endif%}
    {%endfor%}

if __name__ == '__main__':
    """
    This shows an example on how to run the code.  Ideally, your app should do something similar, but use the methods in
    a more meaningful way.
    """
    from time import sleep
    {%set broker = stinger.get_example_broker()%}
    from connection import {{broker.class_name}}

    conn = {{broker.class_name}}({%if broker.hostname is none%}'localhost', 1883{%endif%})
    server = {{stinger.name}}Server(conn)

    {%for sig_name, sig in stinger.signals.items()-%}
    server.emit_{{sig_name}}({%for arg in sig.arg_list%}{{arg.get_random_example_value()}}{%if not loop.last%}, {%endif%}{%endfor%})
    {%endfor%}

    sleep(4)

    {%for sig_name, sig in stinger.signals.items()-%}
    server.emit_{{sig_name}}({%for arg in sig.arg_list%}{{arg.name}}={{arg.get_random_example_value()}}{%if not loop.last%}, {%endif%}{%endfor%})
    {%endfor%}